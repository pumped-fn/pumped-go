# Testing Utilities

Pumped Functions provides several testing utilities and patterns to make testing easier and more efficient. This guide covers advanced testing utilities, custom helpers, and testing strategies.

## Built-in Testing Utilities

### Scope Management

The core testing utility is scope management for isolated tests:

```typescript
import { createScope } from '@pumped-fn/core-next';

describe('Isolated Tests', () => {
  let scope: Scope;

  beforeEach(() => {
    scope = createScope();
  });

  it('should have fresh scope for each test', () => {
    // Each test gets a clean scope
    const result = scope.resolve(myExecutor);
    expect(result).toBeDefined();
  });
});
```

### Executor Utilities

Check executor types and states:

```typescript
import { 
  isLazyExecutor, 
  isReactiveExecutor, 
  isStaticExecutor,
  isMainExecutor 
} from '@pumped-fn/core-next';

describe('Executor Type Checking', () => {
  it('should identify executor types', () => {
    const base = exec(() => 'value');
    
    expect(isMainExecutor(base)).toBe(true);
    expect(isLazyExecutor(base.lazy)).toBe(true);
    expect(isReactiveExecutor(base.reactive)).toBe(true);
    expect(isStaticExecutor(base.static)).toBe(true);
  });
});
```

## Custom Testing Utilities

### Scope Factory

Create a utility for consistent scope creation:

```typescript
// test/utils.ts
import { createScope, Scope } from '@pumped-fn/core-next';

export function createTestScope(): Scope {
  return createScope();
}

export function withScope<T>(
  testFn: (scope: Scope) => T
): T {
  const scope = createTestScope();
  return testFn(scope);
}

// Usage
describe('Calculator', () => {
  it('should add numbers', () => {
    withScope((scope) => {
      const sum = scope.resolve(sumExecutor);
      expect(sum).toBe(8);
    });
  });
});
```

### Executor Builders

Create builders for test data:

```typescript
// test/builders.ts
import { exec, Executor } from '@pumped-fn/core-next';

export class UserBuilder {
  private data = {
    id: '1',
    name: 'Test User',
    email: 'test@example.com',
    active: true,
    preferences: {
      theme: 'light',
      notifications: true,
    },
  };

  withId(id: string) {
    this.data.id = id;
    return this;
  }

  withName(name: string) {
    this.data.name = name;
    return this;
  }

  withEmail(email: string) {
    this.data.email = email;
    return this;
  }

  inactive() {
    this.data.active = false;
    return this;
  }

  withTheme(theme: 'light' | 'dark') {
    this.data.preferences.theme = theme;
    return this;
  }

  build() {
    return { ...this.data };
  }

  buildExecutor(): Executor<typeof this.data> {
    return exec(() => this.build());
  }
}

// Usage
describe('User Profile', () => {
  it('should display user with dark theme', () => {
    const user = new UserBuilder()
      .withName('John Doe')
      .withTheme('dark')
      .buildExecutor();

    const scope = createTestScope();
    const userData = scope.resolve(user);
    
    expect(userData.name).toBe('John Doe');
    expect(userData.preferences.theme).toBe('dark');
  });
});
```

### Mock Executor Factory

Create mock executors with predefined behavior:

```typescript
// test/mocks.ts
import { vi } from 'vitest';
import { exec } from '@pumped-fn/core-next';

export function createMockApiClient() {
  return exec(() => ({
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn(),
  }));
}

export function createMockDatabase() {
  const mockData = new Map();
  
  return exec(() => ({
    save: vi.fn((key, value) => {
      mockData.set(key, value);
      return Promise.resolve(value);
    }),
    find: vi.fn((key) => {
      return Promise.resolve(mockData.get(key));
    }),
    findAll: vi.fn(() => {
      return Promise.resolve(Array.from(mockData.values()));
    }),
    delete: vi.fn((key) => {
      mockData.delete(key);
      return Promise.resolve();
    }),
  }));
}

// Usage
describe('UserService', () => {
  it('should save user to database', async () => {
    const mockDb = createMockDatabase();
    const userService = exec(
      (db) => ({
        saveUser: (user) => db.save(`user:${user.id}`, user),
      }),
      mockDb
    );

    const scope = createTestScope();
    const service = scope.resolve(userService);
    const db = scope.resolve(mockDb);

    await service.saveUser({ id: '1', name: 'John' });

    expect(db.save).toHaveBeenCalledWith('user:1', { id: '1', name: 'John' });
  });
});
```

## Testing Helpers

### Async Testing Helper

Helper for testing async executors:

```typescript
// test/async-helpers.ts
import { Executor, Scope } from '@pumped-fn/core-next';

export async function resolveAsync<T>(
  executor: Executor<T>,
  scope: Scope
): Promise<T> {
  return scope.resolve(executor);
}

export async function expectToResolve<T>(
  executor: Executor<T>,
  expectedValue: T,
  scope = createTestScope()
): Promise<void> {
  const result = await resolveAsync(executor, scope);
  expect(result).toEqual(expectedValue);
}

export async function expectToReject(
  executor: Executor<any>,
  expectedError: string | RegExp,
  scope = createTestScope()
): Promise<void> {
  await expect(resolveAsync(executor, scope))
    .rejects
    .toThrow(expectedError);
}

// Usage
describe('Async Operations', () => {
  it('should resolve with correct value', async () => {
    const asyncExecutor = exec(async () => 'async result');
    await expectToResolve(asyncExecutor, 'async result');
  });

  it('should reject with error', async () => {
    const failingExecutor = exec(async () => {
      throw new Error('Network error');
    });
    await expectToReject(failingExecutor, /Network error/);
  });
});
```

### Reactive Testing Helper

Helper for testing reactive behavior:

```typescript
// test/reactive-helpers.ts
import { Executor, Scope } from '@pumped-fn/core-next';

export function createReactiveTest<T>(
  reactiveExecutor: Executor<T>,
  scope = createTestScope()
) {
  const values: T[] = [];
  
  // Subscribe to changes
  const cleanup = scope.onUpdate(reactiveExecutor, (next) => {
    values.push(next.get());
  });

  return {
    values,
    cleanup,
    expectValues: (expected: T[]) => {
      expect(values).toEqual(expected);
    },
    expectLastValue: (expected: T) => {
      expect(values[values.length - 1]).toEqual(expected);
    },
  };
}

// Usage
describe('Reactive Updates', () => {
  it('should track reactive changes', () => {
    const counter = exec(() => ({ count: 0 }));
    const doubled = exec(
      (state) => state.count * 2,
      counter.reactive
    );

    const scope = createTestScope();
    const test = createReactiveTest(doubled, scope);

    // Make changes
    scope.update(counter, { count: 1 });
    scope.update(counter, { count: 2 });
    scope.update(counter, { count: 3 });

    test.expectValues([2, 4, 6]);
    test.cleanup();
  });
});
```

### State Testing Helper

Helper for testing state management:

```typescript
// test/state-helpers.ts
import { Executor, Scope } from '@pumped-fn/core-next';

export function createStateTest<T>(
  stateExecutor: Executor<T>,
  scope = createTestScope()
) {
  return {
    get: () => scope.resolve(stateExecutor),
    set: (value: T) => scope.update(stateExecutor, value),
    update: (updater: (current: T) => T) => scope.update(stateExecutor, updater),
    expect: (expected: T) => {
      expect(scope.resolve(stateExecutor)).toEqual(expected);
    },
  };
}

// Usage
describe('State Management', () => {
  it('should manage state correctly', () => {
    const counter = exec(() => ({ count: 0 }));
    const state = createStateTest(counter);

    state.expect({ count: 0 });
    
    state.update(s => ({ count: s.count + 1 }));
    state.expect({ count: 1 });
    
    state.set({ count: 10 });
    state.expect({ count: 10 });
  });
});
```

## Test Fixtures

### Complex Test Data

Create fixtures for complex test scenarios:

```typescript
// test/fixtures.ts
import { exec } from '@pumped-fn/core-next';

export const testUsers = [
  { id: '1', name: 'Alice', email: 'alice@example.com', role: 'admin' },
  { id: '2', name: 'Bob', email: 'bob@example.com', role: 'user' },
  { id: '3', name: 'Charlie', email: 'charlie@example.com', role: 'user' },
];

export const testPosts = [
  { id: '1', title: 'First Post', authorId: '1', content: 'Content 1' },
  { id: '2', title: 'Second Post', authorId: '2', content: 'Content 2' },
  { id: '3', title: 'Third Post', authorId: '1', content: 'Content 3' },
];

export const createTestDatabase = () => exec(() => ({
  users: testUsers,
  posts: testPosts,
}));

export const createTestApiClient = () => exec(() => ({
  getUsers: vi.fn().mockResolvedValue(testUsers),
  getPosts: vi.fn().mockResolvedValue(testPosts),
  createPost: vi.fn().mockImplementation((post) => 
    Promise.resolve({ ...post, id: String(Date.now()) })
  ),
}));

// Usage
describe('Blog Service', () => {
  it('should fetch posts with authors', async () => {
    const db = createTestDatabase();
    const blogService = exec(
      (database) => ({
        getPostsWithAuthors: () => {
          return database.posts.map(post => ({
            ...post,
            author: database.users.find(u => u.id === post.authorId),
          }));
        },
      }),
      db
    );

    const scope = createTestScope();
    const service = scope.resolve(blogService);
    const posts = service.getPostsWithAuthors();

    expect(posts).toHaveLength(3);
    expect(posts[0].author.name).toBe('Alice');
  });
});
```

### Environment Fixtures

Create different environment configurations:

```typescript
// test/environments.ts
import { exec } from '@pumped-fn/core-next';

export const developmentConfig = exec(() => ({
  apiUrl: 'http://localhost:3000',
  debug: true,
  logLevel: 'debug',
  features: {
    newUI: true,
    analytics: false,
  },
}));

export const productionConfig = exec(() => ({
  apiUrl: 'https://api.production.com',
  debug: false,
  logLevel: 'error',
  features: {
    newUI: false,
    analytics: true,
  },
}));

export const testConfig = exec(() => ({
  apiUrl: 'http://localhost:3001',
  debug: false,
  logLevel: 'silent',
  features: {
    newUI: true,
    analytics: false,
  },
}));

// Usage
describe('Feature Service', () => {
  it('should enable new UI in development', () => {
    const featureService = exec(
      (config) => ({
        isEnabled: (feature) => config.features[feature],
      }),
      developmentConfig
    );

    const scope = createTestScope();
    const service = scope.resolve(featureService);

    expect(service.isEnabled('newUI')).toBe(true);
  });

  it('should disable new UI in production', () => {
    const featureService = exec(
      (config) => ({
        isEnabled: (feature) => config.features[feature],
      }),
      productionConfig
    );

    const scope = createTestScope();
    const service = scope.resolve(featureService);

    expect(service.isEnabled('newUI')).toBe(false);
  });
});
```

## Test Suites

### Shared Test Suites

Create reusable test suites:

```typescript
// test/suites.ts
import { Executor, Scope } from '@pumped-fn/core-next';

export function testCrudOperations<T>(
  serviceExecutor: Executor<any>,
  testData: T,
  scope = createTestScope()
) {
  const service = scope.resolve(serviceExecutor);

  describe('CRUD Operations', () => {
    it('should create item', async () => {
      const created = await service.create(testData);
      expect(created).toMatchObject(testData);
    });

    it('should read item', async () => {
      const created = await service.create(testData);
      const read = await service.read(created.id);
      expect(read).toEqual(created);
    });

    it('should update item', async () => {
      const created = await service.create(testData);
      const updated = await service.update(created.id, { ...testData, updated: true });
      expect(updated.updated).toBe(true);
    });

    it('should delete item', async () => {
      const created = await service.create(testData);
      await service.delete(created.id);
      const read = await service.read(created.id);
      expect(read).toBe(null);
    });
  });
}

// Usage
describe('UserService', () => {
  testCrudOperations(
    userServiceExecutor,
    { name: 'Test User', email: 'test@example.com' }
  );
});
```

### Validation Test Suite

Test validation logic:

```typescript
// test/validation-suite.ts
export function testValidation<T>(
  validatorExecutor: Executor<any>,
  testCases: { input: T; expected: boolean; description: string }[]
) {
  describe('Validation', () => {
    testCases.forEach(({ input, expected, description }) => {
      it(description, () => {
        const scope = createTestScope();
        const validator = scope.resolve(validatorExecutor);
        const result = validator.validate(input);
        expect(result.isValid).toBe(expected);
      });
    });
  });
}

// Usage
const emailValidationCases = [
  { input: 'test@example.com', expected: true, description: 'should accept valid email' },
  { input: 'invalid-email', expected: false, description: 'should reject invalid email' },
  { input: '', expected: false, description: 'should reject empty email' },
];

describe('EmailValidator', () => {
  testValidation(emailValidatorExecutor, emailValidationCases);
});
```

## Performance Testing Utilities

### Performance Measurement

```typescript
// test/performance.ts
import { performance } from 'perf_hooks';

export function measurePerformance<T>(
  testFn: () => T,
  maxDuration = 100
): T {
  const start = performance.now();
  const result = testFn();
  const end = performance.now();
  const duration = end - start;

  expect(duration).toBeLessThan(maxDuration);
  return result;
}

export async function measureAsyncPerformance<T>(
  testFn: () => Promise<T>,
  maxDuration = 100
): Promise<T> {
  const start = performance.now();
  const result = await testFn();
  const end = performance.now();
  const duration = end - start;

  expect(duration).toBeLessThan(maxDuration);
  return result;
}

// Usage
describe('Performance', () => {
  it('should resolve quickly', () => {
    measurePerformance(() => {
      const scope = createTestScope();
      return scope.resolve(complexExecutor);
    }, 50); // Max 50ms
  });

  it('should handle async operations efficiently', async () => {
    await measureAsyncPerformance(async () => {
      const scope = createTestScope();
      return scope.resolve(asyncExecutor);
    }, 200); // Max 200ms
  });
});
```

### Memory Testing

```typescript
// test/memory.ts
export function measureMemoryUsage<T>(
  testFn: () => T,
  maxMemoryIncrease = 1024 * 1024 // 1MB
): T {
  const initialMemory = process.memoryUsage().heapUsed;
  const result = testFn();
  
  // Force garbage collection if available
  if (global.gc) {
    global.gc();
  }
  
  const finalMemory = process.memoryUsage().heapUsed;
  const memoryIncrease = finalMemory - initialMemory;

  expect(memoryIncrease).toBeLessThan(maxMemoryIncrease);
  return result;
}

// Usage
describe('Memory Usage', () => {
  it('should not leak memory', () => {
    measureMemoryUsage(() => {
      const scope = createTestScope();
      // Create many executors
      for (let i = 0; i < 1000; i++) {
        scope.resolve(exec(() => i));
      }
      // Release scope
      scope.release();
    });
  });
});
```

## Integration with Testing Frameworks

### Jest Setup

```typescript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],
  testMatch: ['**/__tests__/**/*.test.ts'],
};

// src/test/setup.ts
import { createTestScope } from './utils';

// Global test utilities
global.createTestScope = createTestScope;

// Setup and teardown
beforeEach(() => {
  // Reset any global state
});

afterEach(() => {
  // Cleanup after each test
});
```

### Vitest Configuration

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    globals: true,
    testTimeout: 10000,
  },
});
```

## Best Practices

### 1. Organize Test Utilities

```typescript
// test/index.ts
export * from './utils';
export * from './builders';
export * from './mocks';
export * from './fixtures';
export * from './async-helpers';
export * from './reactive-helpers';
export * from './state-helpers';
```

### 2. Use Consistent Naming

```typescript
// Clear naming conventions
describe('UserService', () => {
  describe('createUser', () => {
    it('should create user with valid data', () => {
      // Test implementation
    });

    it('should reject invalid email', () => {
      // Test implementation
    });
  });
});
```

### 3. Document Test Utilities

```typescript
/**
 * Creates a test scope with optional presets
 * @param presets - Optional preset values for executors
 * @returns A new test scope
 */
export function createTestScope(presets?: Preset[]): Scope {
  return createScope(...(presets || []));
}
```

## Next Steps

- [Interactive Testing](/testing/interactive-testing) - Testing complex user interactions
- [Testing Overview](/testing/overview) - Back to testing overview
- [Testing Executors](/testing/testing-executors) - Executor-specific testing

These testing utilities provide a comprehensive toolkit for testing Pumped Functions applications. They help reduce boilerplate, improve test readability, and ensure consistent testing practices across your codebase.