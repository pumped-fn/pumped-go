# Testing React Components

Testing React components that use Pumped Functions is straightforward thanks to the clean separation between logic (executors) and presentation (components). This guide covers comprehensive testing strategies for React integration.

## Setup

### Testing Dependencies

```bash
pnpm add -D @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

### Test Setup

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
  },
});
```

```typescript
// src/test/setup.ts
import '@testing-library/jest-dom';
```

## Basic Component Testing

### Simple Component

Test a component that uses `useResolves`:

```typescript
import { render, screen } from '@testing-library/react';
import { exec } from '@pumped-fn/core-next';
import { ScopeProvider } from '@pumped-fn/react';
import { UserProfile } from './UserProfile';

// Component under test
function UserProfile() {
  const [user] = useResolves(userExecutor);
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

// Test
describe('UserProfile', () => {
  it('should render user information', () => {
    const userExecutor = exec(() => ({
      name: 'John Doe',
      email: 'john@example.com'
    }));

    render(
      <ScopeProvider>
        <UserProfile />
      </ScopeProvider>
    );

    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });
});
```

### Component with Multiple Executors

```typescript
import { render, screen } from '@testing-library/react';
import { exec } from '@pumped-fn/core-next';
import { ScopeProvider } from '@pumped-fn/react';

function Dashboard() {
  const [user, notifications, settings] = useResolves(
    userExecutor,
    notificationsExecutor,
    settingsExecutor
  );

  return (
    <div>
      <h1>Welcome {user.name}!</h1>
      <p>You have {notifications.length} notifications</p>
      <p>Theme: {settings.theme}</p>
    </div>
  );
}

describe('Dashboard', () => {
  it('should render all data correctly', () => {
    const userExecutor = exec(() => ({ name: 'John' }));
    const notificationsExecutor = exec(() => [
      { id: 1, message: 'Hello' },
      { id: 2, message: 'World' }
    ]);
    const settingsExecutor = exec(() => ({ theme: 'dark' }));

    render(
      <ScopeProvider>
        <Dashboard />
      </ScopeProvider>
    );

    expect(screen.getByText('Welcome John!')).toBeInTheDocument();
    expect(screen.getByText('You have 2 notifications')).toBeInTheDocument();
    expect(screen.getByText('Theme: dark')).toBeInTheDocument();
  });
});
```

## Testing with Custom Scopes

### Pre-populated Scope

Test components with pre-set data:

```typescript
import { createScope } from '@pumped-fn/core-next';
import { ScopeProvider } from '@pumped-fn/react';

describe('UserProfile with preset data', () => {
  it('should use preset user data', () => {
    const scope = createScope();
    const testUser = { name: 'Test User', email: 'test@example.com' };
    
    // Pre-populate the scope
    scope.update(userExecutor, testUser);

    render(
      <ScopeProvider scope={scope}>
        <UserProfile />
      </ScopeProvider>
    );

    expect(screen.getByText('Test User')).toBeInTheDocument();
    expect(screen.getByText('test@example.com')).toBeInTheDocument();
  });
});
```

### Scope with Presets

```typescript
describe('Dashboard with presets', () => {
  it('should use preset values', () => {
    const presets = [
      { executor: userExecutor, value: { name: 'Preset User' } },
      { executor: settingsExecutor, value: { theme: 'light' } }
    ];

    render(
      <ScopeProvider presets={presets}>
        <Dashboard />
      </ScopeProvider>
    );

    expect(screen.getByText('Welcome Preset User!')).toBeInTheDocument();
    expect(screen.getByText('Theme: light')).toBeInTheDocument();
  });
});
```

## Testing User Interactions

### Button Clicks and Updates

Test components that update state:

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

function Counter() {
  const [count] = useResolves(counterExecutor);
  const updateCounter = useUpdate(counterExecutor);

  const increment = () => {
    updateCounter((current) => ({ count: current.count + 1 }));
  };

  return (
    <div>
      <p data-testid="count">Count: {count.count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

describe('Counter', () => {
  it('should increment count when button is clicked', async () => {
    const user = userEvent.setup();
    const counterExecutor = exec(() => ({ count: 0 }));

    render(
      <ScopeProvider>
        <Counter />
      </ScopeProvider>
    );

    expect(screen.getByTestId('count')).toHaveTextContent('Count: 0');

    await user.click(screen.getByText('Increment'));

    expect(screen.getByTestId('count')).toHaveTextContent('Count: 1');
  });
});
```

### Form Interactions

Test form components:

```typescript
function UserForm() {
  const [user] = useResolves(userExecutor);
  const updateUser = useUpdate(userExecutor);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    const name = formData.get('name') as string;
    updateUser((current) => ({ ...current, name }));
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" defaultValue={user.name} />
      <button type="submit">Update</button>
      <p data-testid="user-name">{user.name}</p>
    </form>
  );
}

describe('UserForm', () => {
  it('should update user name when form is submitted', async () => {
    const user = userEvent.setup();
    const userExecutor = exec(() => ({ name: 'John' }));

    render(
      <ScopeProvider>
        <UserForm />
      </ScopeProvider>
    );

    const nameInput = screen.getByDisplayValue('John');
    await user.clear(nameInput);
    await user.type(nameInput, 'Jane');
    await user.click(screen.getByText('Update'));

    expect(screen.getByTestId('user-name')).toHaveTextContent('Jane');
  });
});
```

## Testing Reactive Components

### Reactive Updates

Test components that respond to reactive changes:

```typescript
function ReactiveDisplay() {
  const [count, doubled] = useResolves(counterExecutor, doubledExecutor);

  return (
    <div>
      <p data-testid="count">Count: {count.count}</p>
      <p data-testid="doubled">Doubled: {doubled}</p>
    </div>
  );
}

describe('ReactiveDisplay', () => {
  it('should update doubled value when count changes', () => {
    const counterExecutor = exec(() => ({ count: 5 }));
    const doubledExecutor = exec(
      (state) => state.count * 2,
      counterExecutor.reactive
    );

    const scope = createScope();
    
    render(
      <ScopeProvider scope={scope}>
        <ReactiveDisplay />
      </ScopeProvider>
    );

    expect(screen.getByTestId('count')).toHaveTextContent('Count: 5');
    expect(screen.getByTestId('doubled')).toHaveTextContent('Doubled: 10');

    // Update the counter
    scope.update(counterExecutor, { count: 7 });

    expect(screen.getByTestId('count')).toHaveTextContent('Count: 7');
    expect(screen.getByTestId('doubled')).toHaveTextContent('Doubled: 14');
  });
});
```

### Multiple Reactive Dependencies

```typescript
function Calculator() {
  const [a, b, sum] = useResolves(aExecutor, bExecutor, sumExecutor);

  return (
    <div>
      <p data-testid="a">A: {a}</p>
      <p data-testid="b">B: {b}</p>
      <p data-testid="sum">Sum: {sum}</p>
    </div>
  );
}

describe('Calculator', () => {
  it('should update sum when either input changes', () => {
    const aExecutor = exec(() => 10);
    const bExecutor = exec(() => 20);
    const sumExecutor = exec(
      (a: number, b: number) => a + b,
      [aExecutor.reactive, bExecutor.reactive]
    );

    const scope = createScope();
    
    render(
      <ScopeProvider scope={scope}>
        <Calculator />
      </ScopeProvider>
    );

    expect(screen.getByTestId('sum')).toHaveTextContent('Sum: 30');

    // Update first input
    scope.update(aExecutor, 15);
    expect(screen.getByTestId('sum')).toHaveTextContent('Sum: 35');

    // Update second input
    scope.update(bExecutor, 25);
    expect(screen.getByTestId('sum')).toHaveTextContent('Sum: 40');
  });
});
```

## Testing Async Components

### Loading States

Test components with async data:

```typescript
function AsyncUserProfile() {
  const [user] = useResolves(asyncUserExecutor);

  if (!user) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

describe('AsyncUserProfile', () => {
  it('should show loading state initially', () => {
    const asyncUserExecutor = exec(async () => {
      await new Promise(resolve => setTimeout(resolve, 100));
      return { name: 'John', email: 'john@example.com' };
    });

    render(
      <ScopeProvider>
        <AsyncUserProfile />
      </ScopeProvider>
    );

    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('should show user data after loading', async () => {
    const asyncUserExecutor = exec(async () => {
      return { name: 'John', email: 'john@example.com' };
    });

    render(
      <ScopeProvider>
        <AsyncUserProfile />
      </ScopeProvider>
    );

    await screen.findByText('John');
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });
});
```

### Error Boundaries

Test error handling:

```typescript
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error }) {
  return (
    <div role="alert">
      <h2>Something went wrong:</h2>
      <pre>{error.message}</pre>
    </div>
  );
}

function FailingComponent() {
  const [data] = useResolves(failingExecutor);
  return <div>{data.value}</div>;
}

describe('Error Handling', () => {
  it('should display error when executor fails', () => {
    const failingExecutor = exec(() => {
      throw new Error('Network error');
    });

    render(
      <ErrorBoundary FallbackComponent={ErrorFallback}>
        <ScopeProvider>
          <FailingComponent />
        </ScopeProvider>
      </ErrorBoundary>
    );

    expect(screen.getByRole('alert')).toBeInTheDocument();
    expect(screen.getByText(/Network error/)).toBeInTheDocument();
  });
});
```

## Testing with Render Props

### Resolves Component

```typescript
function UserDisplay() {
  return (
    <Resolves e={[userExecutor, settingsExecutor]}>
      {([user, settings]) => (
        <div>
          <h1>{user.name}</h1>
          <p>Theme: {settings.theme}</p>
        </div>
      )}
    </Resolves>
  );
}

describe('UserDisplay', () => {
  it('should render with render props pattern', () => {
    const userExecutor = exec(() => ({ name: 'John' }));
    const settingsExecutor = exec(() => ({ theme: 'dark' }));

    render(
      <ScopeProvider>
        <UserDisplay />
      </ScopeProvider>
    );

    expect(screen.getByText('John')).toBeInTheDocument();
    expect(screen.getByText('Theme: dark')).toBeInTheDocument();
  });
});
```

### Reselect Component

```typescript
function UserName() {
  return (
    <Reselect 
      e={userExecutor}
      selector={(user) => user.name}
    >
      {(name) => <h1>Hello {name}!</h1>}
    </Reselect>
  );
}

describe('UserName', () => {
  it('should render with selector', () => {
    const userExecutor = exec(() => ({ 
      name: 'John', 
      email: 'john@example.com' 
    }));

    render(
      <ScopeProvider>
        <UserName />
      </ScopeProvider>
    );

    expect(screen.getByText('Hello John!')).toBeInTheDocument();
  });
});
```

## Testing Utilities

### Custom Render Function

Create a custom render function for convenience:

```typescript
// test/utils.tsx
import { render } from '@testing-library/react';
import { ReactElement } from 'react';
import { ScopeProvider } from '@pumped-fn/react';
import { createScope } from '@pumped-fn/core-next';

export function renderWithScope(
  ui: ReactElement,
  { scope = createScope(), ...renderOptions } = {}
) {
  function Wrapper({ children }: { children: React.ReactNode }) {
    return <ScopeProvider scope={scope}>{children}</ScopeProvider>;
  }

  return {
    scope,
    ...render(ui, { wrapper: Wrapper, ...renderOptions })
  };
}

// Usage
describe('UserProfile', () => {
  it('should render user information', () => {
    const { scope } = renderWithScope(<UserProfile />);
    
    // Pre-populate scope if needed
    scope.update(userExecutor, { name: 'Test User' });
    
    expect(screen.getByText('Test User')).toBeInTheDocument();
  });
});
```

### Mock Executors

Create mock executors for testing:

```typescript
// test/mocks.ts
import { vi } from 'vitest';
import { exec } from '@pumped-fn/core-next';

export function createMockApiExecutor() {
  return exec(() => ({
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn(),
  }));
}

export function createMockUserExecutor(user = {}) {
  return exec(() => ({
    id: '1',
    name: 'Test User',
    email: 'test@example.com',
    ...user,
  }));
}

// Usage
describe('UserService', () => {
  it('should fetch user data', async () => {
    const mockApi = createMockApiExecutor();
    const mockUser = createMockUserExecutor({ name: 'John' });

    const { scope } = renderWithScope(<UserComponent />);
    
    // Setup mock response
    const api = scope.resolve(mockApi);
    api.get.mockResolvedValue(scope.resolve(mockUser));

    // Test implementation
  });
});
```

## Integration Testing

### Full Component Trees

Test complete component hierarchies:

```typescript
function App() {
  return (
    <ScopeProvider>
      <Header />
      <Dashboard />
      <Footer />
    </ScopeProvider>
  );
}

describe('App Integration', () => {
  it('should render complete application', () => {
    render(<App />);

    expect(screen.getByRole('banner')).toBeInTheDocument(); // Header
    expect(screen.getByRole('main')).toBeInTheDocument(); // Dashboard
    expect(screen.getByRole('contentinfo')).toBeInTheDocument(); // Footer
  });

  it('should handle user interactions across components', async () => {
    const user = userEvent.setup();
    render(<App />);

    // Test cross-component interactions
    await user.click(screen.getByText('Login'));
    expect(screen.getByText('Welcome!')).toBeInTheDocument();
  });
});
```

## Performance Testing

### Render Performance

Test that components don't re-render unnecessarily:

```typescript
describe('Performance', () => {
  it('should not re-render when unrelated data changes', () => {
    let renderCount = 0;
    
    function TestComponent() {
      renderCount++;
      const [userName] = useResolves(userNameExecutor);
      return <div>{userName}</div>;
    }

    const userNameExecutor = exec(() => 'John');
    const unrelatedExecutor = exec(() => 'unrelated');

    const { scope } = renderWithScope(<TestComponent />);
    
    expect(renderCount).toBe(1);
    
    // Update unrelated data
    scope.update(unrelatedExecutor, 'updated');
    
    // Component should not re-render
    expect(renderCount).toBe(1);
  });
});
```

## Best Practices

### 1. Test Behavior, Not Implementation

```typescript
// Good - tests behavior
it('should show user greeting', () => {
  renderWithScope(<UserGreeting />);
  expect(screen.getByText(/welcome/i)).toBeInTheDocument();
});

// Less good - tests implementation details
it('should call useResolves with userExecutor', () => {
  const spy = vi.spyOn(require('@pumped-fn/react'), 'useResolves');
  renderWithScope(<UserGreeting />);
  expect(spy).toHaveBeenCalledWith(userExecutor);
});
```

### 2. Use Semantic Queries

```typescript
// Good - semantic queries
expect(screen.getByRole('button', { name: /submit/i })).toBeInTheDocument();
expect(screen.getByLabelText(/email/i)).toBeInTheDocument();

// Less good - implementation details
expect(screen.getByClassName('submit-button')).toBeInTheDocument();
```

### 3. Test Edge Cases

```typescript
describe('UserList', () => {
  it('should handle empty user list', () => {
    const emptyUsersExecutor = exec(() => []);
    renderWithScope(<UserList />);
    expect(screen.getByText('No users found')).toBeInTheDocument();
  });

  it('should handle loading state', () => {
    const loadingUsersExecutor = exec(() => null);
    renderWithScope(<UserList />);
    expect(screen.getByText('Loading users...')).toBeInTheDocument();
  });
});
```

## Next Steps

- [Testing Utilities](/testing/testing-utilities) - Advanced testing utilities and helpers
- [Interactive Testing](/testing/interactive-testing) - Testing complex user interactions
- [Testing Executors](/testing/testing-executors) - Deep dive into executor testing

Testing React components with Pumped Functions is straightforward and powerful. The separation of concerns makes it easy to test both the logic (executors) and the presentation (components) independently and together.