# Quick Start

Learn Pumped Functions in 5 minutes! This guide will walk you through the core concepts and get you building reactive applications.

## Basic Concepts

Pumped Functions is built around three main concepts:

1. **Executors** - Containers that hold values and define dependencies
2. **Scopes** - Resolution contexts that manage executor lifecycles
3. **Reactivity** - Automatic dependency tracking and updates

## Your First Executor

Let's start with a simple executor:

```typescript
import { exec, createScope } from '@pumped-fn/core-next';

// Create an executor that returns a value
const greeting = exec(() => 'Hello, World!');

// Create a scope to resolve executors
const scope = createScope();

// Resolve the executor to get its value
const result = scope.resolve(greeting);
console.log(result); // "Hello, World!"
```

## Executors with Dependencies

Executors can depend on other executors:

```typescript
import { exec, createScope } from '@pumped-fn/core-next';

// Base executors
const firstName = exec(() => 'John');
const lastName = exec(() => 'Doe');

// Executor that depends on other executors
const fullName = exec(
  (first: string, last: string) => `${first} ${last}`,
  [firstName, lastName]
);

const scope = createScope();
const result = scope.resolve(fullName);
console.log(result); // "John Doe"
```

## Reactive Programming

Make your executors reactive to automatically update when dependencies change:

```typescript
import { exec, createScope } from '@pumped-fn/core-next';

// Create a counter executor
const counter = exec(() => ({ count: 0 }));

// Create a reactive executor that depends on the counter
const doubled = exec(
  (state) => state.count * 2,
  counter.reactive // .reactive makes it reactive
);

const scope = createScope();

// Initial values
console.log(scope.resolve(doubled)); // 0

// Update the counter
scope.update(counter, (state) => ({ count: state.count + 1 }));

// Doubled automatically updates
console.log(scope.resolve(doubled)); // 2
```

## React Integration

Use Pumped Functions with React for reactive UIs:

```typescript
import React from 'react';
import { exec } from '@pumped-fn/core-next';
import { useResolves, useUpdate, ScopeProvider } from '@pumped-fn/react';

// Create executors
const counter = exec(() => ({ count: 0 }));
const doubled = exec((state) => state.count * 2, counter.reactive);

function Counter() {
  // Resolve multiple executors at once
  const [counterState, doubledValue] = useResolves(counter, doubled);
  
  // Get update function
  const updateCounter = useUpdate(counter);

  return (
    <div>
      <p>Count: {counterState.count}</p>
      <p>Doubled: {doubledValue}</p>
      <button onClick={() => updateCounter(s => ({ count: s.count + 1 }))}>
        Increment
      </button>
    </div>
  );
}

function App() {
  return (
    <ScopeProvider>
      <Counter />
    </ScopeProvider>
  );
}
```

## Advanced Patterns

### Async Executors

Executors can handle async operations:

```typescript
import { exec, createScope } from '@pumped-fn/core-next';

// Async executor
const userData = exec(async () => {
  const response = await fetch('/api/user');
  return response.json();
});

const scope = createScope();

// Resolve async executor
const user = await scope.resolve(userData);
console.log(user);
```

### Object Dependencies

Use objects to name your dependencies:

```typescript
import { exec, createScope } from '@pumped-fn/core-next';

const userPreferences = exec(() => ({ theme: 'dark', lang: 'en' }));
const userProfile = exec(() => ({ name: 'John', email: 'john@example.com' }));

const appSettings = exec(
  ({ preferences, profile }) => ({
    ...preferences,
    userName: profile.name,
    userEmail: profile.email,
  }),
  {
    preferences: userPreferences,
    profile: userProfile,
  }
);

const scope = createScope();
const settings = scope.resolve(appSettings);
console.log(settings);
// { theme: 'dark', lang: 'en', userName: 'John', userEmail: 'john@example.com' }
```

### Lazy Resolution

Use `.lazy` for executors that should only resolve when needed:

```typescript
import { exec, createScope } from '@pumped-fn/core-next';

const expensiveComputation = exec(() => {
  console.log('Computing...');
  return Math.random() * 1000;
});

const maybeUseValue = exec(
  (value: number) => value > 500 ? value : null,
  expensiveComputation.lazy // Only resolves if needed
);

const scope = createScope();
const result = scope.resolve(maybeUseValue);
```

## Testing

Testing with Pumped Functions is straightforward:

```typescript
import { describe, it, expect } from 'vitest';
import { exec, createScope } from '@pumped-fn/core-next';

describe('Calculator', () => {
  it('should add two numbers', () => {
    const a = exec(() => 5);
    const b = exec(() => 3);
    const sum = exec((a: number, b: number) => a + b, [a, b]);

    const scope = createScope();
    const result = scope.resolve(sum);

    expect(result).toBe(8);
  });

  it('should handle updates', () => {
    const counter = exec(() => ({ count: 0 }));
    const doubled = exec((state) => state.count * 2, counter.reactive);

    const scope = createScope();
    
    expect(scope.resolve(doubled)).toBe(0);
    
    scope.update(counter, { count: 5 });
    expect(scope.resolve(doubled)).toBe(10);
  });
});
```

## Key Takeaways

1. **Executors are containers** - They hold values and define how to create them
2. **Scopes manage resolution** - Create a scope to resolve executors
3. **Dependencies are explicit** - Pass dependencies as the second parameter
4. **Reactivity is opt-in** - Use `.reactive` to make executors reactive
5. **React integration is seamless** - Use hooks like `useResolves` and `useUpdate`

## Next Steps

Now that you understand the basics, explore:

- [Your First App](/getting-started/first-app) - Build a complete application
- [Core Concepts](/core-concepts/executors) - Deep dive into executors and scopes
- [React Integration](/react/overview) - Advanced React patterns
- [Testing](/testing/overview) - Comprehensive testing strategies

## Common Patterns

### State Management

```typescript
// Global state executor
const appState = exec(() => ({
  user: null,
  theme: 'light',
  notifications: [],
}));

// Derived state
const isLoggedIn = exec(
  (state) => state.user !== null,
  appState.reactive
);

// Actions
const login = exec(
  (user: User) => (state: AppState) => ({
    ...state,
    user,
  }),
  [userExecutor]
);
```

### API Integration

```typescript
// API executor with caching
const apiClient = exec(() => new ApiClient());

const userProfile = exec(
  async (client: ApiClient, userId: string) => {
    return client.getUser(userId);
  },
  [apiClient, currentUserId]
);
```

### Configuration

```typescript
// Environment-based configuration
const config = exec(() => ({
  apiUrl: process.env.API_URL || 'http://localhost:3000',
  isDev: process.env.NODE_ENV === 'development',
}));

// Feature flags
const features = exec(
  (config) => ({
    newUI: config.isDev,
    analytics: !config.isDev,
  }),
  config
);
```

Ready to build something amazing? Let's create [your first app](/getting-started/first-app)!