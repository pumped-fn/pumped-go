# React Integration

Pumped Functions provides seamless React integration through hooks and components that make it easy to use executors in React applications. The integration leverages React's concurrent features for optimal performance.

## Installation

```bash
pnpm add @pumped-fn/react
```

The React package requires `@pumped-fn/core-next` and `react` as peer dependencies.

## Core Concepts

### ScopeProvider

The `ScopeProvider` creates a scope context that all child components can access:

```typescript
import { ScopeProvider } from '@pumped-fn/react';

function App() {
  return (
    <ScopeProvider>
      <MyComponent />
    </ScopeProvider>
  );
}
```

### useResolves Hook

The primary hook for resolving executors in React components:

```typescript
import { useResolves } from '@pumped-fn/react';

function MyComponent() {
  const [userData, config] = useResolves(userExecutor, configExecutor);
  
  return (
    <div>
      <h1>Welcome {userData.name}!</h1>
      <p>API URL: {config.apiUrl}</p>
    </div>
  );
}
```

## Essential Hooks

### useResolves

Resolve multiple executors at once:

```typescript
import { useResolves } from '@pumped-fn/react';

function Dashboard() {
  const [user, notifications, settings] = useResolves(
    userExecutor,
    notificationsExecutor,
    settingsExecutor
  );

  return (
    <div>
      <h1>Welcome {user.name}!</h1>
      <p>You have {notifications.length} notifications</p>
      <p>Theme: {settings.theme}</p>
    </div>
  );
}
```

### useResolve with Selector

For performance optimization, use selectors to subscribe to specific parts of the state:

```typescript
import { useResolve } from '@pumped-fn/react';

function UserName() {
  const userName = useResolve(
    userExecutor,
    (user) => user.name  // Selector function
  );

  return <span>{userName}</span>;
}

// With equality check
function UserEmail() {
  const userEmail = useResolve(
    userExecutor,
    (user) => user.email,
    {
      equality: (a, b) => a === b,  // Custom equality
      snapshot: (email) => email,   // Snapshot for stability
    }
  );

  return <span>{userEmail}</span>;
}
```

### useUpdate

Update executor values from React components:

```typescript
import { useUpdate } from '@pumped-fn/react';

function Counter() {
  const [count] = useResolves(counterExecutor);
  const updateCounter = useUpdate(counterExecutor);

  const increment = () => {
    updateCounter((current) => ({ count: current.count + 1 }));
  };

  const reset = () => {
    updateCounter({ count: 0 });
  };

  return (
    <div>
      <p>Count: {count.count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

### useScope

Access the current scope directly:

```typescript
import { useScope } from '@pumped-fn/react';

function AdvancedComponent() {
  const scope = useScope();

  const handleManualResolve = () => {
    const value = scope.resolve(someExecutor);
    console.log('Manually resolved:', value);
  };

  return (
    <button onClick={handleManualResolve}>
      Manual Resolve
    </button>
  );
}
```

### useRelease

Release an executor and clean up its resources:

```typescript
import { useRelease } from '@pumped-fn/react';

function ResourceManager() {
  const [resource] = useResolves(expensiveResourceExecutor);
  const releaseResource = useRelease(expensiveResourceExecutor);

  const cleanup = () => {
    releaseResource();
  };

  return (
    <div>
      <p>Resource: {resource.name}</p>
      <button onClick={cleanup}>Cleanup</button>
    </div>
  );
}
```

## React Components

### ScopeProvider

Create and manage scopes:

```typescript
import { ScopeProvider, createScope } from '@pumped-fn/react';

// Basic usage
function App() {
  return (
    <ScopeProvider>
      <Dashboard />
    </ScopeProvider>
  );
}

// With custom scope
function AppWithCustomScope() {
  const customScope = createScope();
  
  return (
    <ScopeProvider scope={customScope}>
      <Dashboard />
    </ScopeProvider>
  );
}

// With presets
function AppWithPresets() {
  const presets = [
    { executor: configExecutor, value: defaultConfig },
    { executor: userExecutor, value: guestUser },
  ];
  
  return (
    <ScopeProvider presets={presets}>
      <Dashboard />
    </ScopeProvider>
  );
}
```

### Resolves Component

Render props pattern for resolving executors:

```typescript
import { Resolves } from '@pumped-fn/react';

function UserProfile() {
  return (
    <Resolves e={[userExecutor, settingsExecutor]}>
      {([user, settings]) => (
        <div>
          <h1>{user.name}</h1>
          <p>Theme: {settings.theme}</p>
        </div>
      )}
    </Resolves>
  );
}
```

### Reselect Component

Render props with selector:

```typescript
import { Reselect } from '@pumped-fn/react';

function UserName() {
  return (
    <Reselect 
      e={userExecutor}
      selector={(user) => user.name}
    >
      {(name) => <h1>Hello {name}!</h1>}
    </Reselect>
  );
}
```

### Reactives Component

Automatically make executors reactive:

```typescript
import { Reactives } from '@pumped-fn/react';

function ReactiveDisplay() {
  return (
    <Reactives e={[counterExecutor, timerExecutor]}>
      {([counter, timer]) => (
        <div>
          <p>Count: {counter.count}</p>
          <p>Time: {timer.seconds}</p>
        </div>
      )}
    </Reactives>
  );
}
```

### Effect Component

Handle side effects:

```typescript
import { Effect } from '@pumped-fn/react';

function App() {
  return (
    <div>
      <Effect e={[loggingExecutor, analyticsExecutor]} />
      <MainContent />
    </div>
  );
}
```

## Reactive Programming

### Automatic Updates

React components automatically re-render when reactive executors change:

```typescript
const counter = exec(() => ({ count: 0 }));
const doubled = exec(
  (state) => state.count * 2,
  counter.reactive  // This makes it reactive
);

function ReactiveCounter() {
  const [count, doubledValue] = useResolves(counter, doubled);
  const updateCounter = useUpdate(counter);

  // When counter updates, doubled automatically updates too
  return (
    <div>
      <p>Count: {count.count}</p>
      <p>Doubled: {doubledValue}</p>
      <button onClick={() => updateCounter(c => ({ count: c.count + 1 }))}>
        Increment
      </button>
    </div>
  );
}
```

### Concurrent Features

The React integration uses React's concurrent features for optimal performance:

```typescript
import { startTransition } from 'react';

function OptimizedComponent() {
  const [data] = useResolves(dataExecutor);
  const updateData = useUpdate(dataExecutor);

  const handleUpdate = () => {
    startTransition(() => {
      updateData(newData);
    });
  };

  return (
    <div>
      <DisplayData data={data} />
      <button onClick={handleUpdate}>Update</button>
    </div>
  );
}
```

## Advanced Patterns

### Conditional Rendering

```typescript
function ConditionalApp() {
  const [user] = useResolves(userExecutor);
  
  if (!user) {
    return <LoginForm />;
  }

  return (
    <ScopeProvider>
      <UserDashboard />
    </ScopeProvider>
  );
}
```

### Error Boundaries

Handle errors from executors:

```typescript
import { ErrorBoundary } from 'react-error-boundary';

function ErrorFallback({ error }) {
  return (
    <div role="alert">
      <h2>Something went wrong:</h2>
      <pre>{error.message}</pre>
    </div>
  );
}

function App() {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <ScopeProvider>
        <Dashboard />
      </ScopeProvider>
    </ErrorBoundary>
  );
}
```

### Suspense Integration

Handle async executors with Suspense:

```typescript
import { Suspense } from 'react';

function AsyncComponent() {
  const [data] = useResolves(asyncDataExecutor);
  
  return <div>{data.content}</div>;
}

function App() {
  return (
    <ScopeProvider>
      <Suspense fallback={<div>Loading...</div>}>
        <AsyncComponent />
      </Suspense>
    </ScopeProvider>
  );
}
```

## Performance Optimization

### Selective Updates

Use selectors to limit re-renders:

```typescript
// Only re-renders when user.name changes
function UserName() {
  const name = useResolve(userExecutor, (user) => user.name);
  return <h1>{name}</h1>;
}

// Only re-renders when user.email changes
function UserEmail() {
  const email = useResolve(userExecutor, (user) => user.email);
  return <p>{email}</p>;
}
```

### Memoization

Combine with React.memo for optimal performance:

```typescript
import { memo } from 'react';

const UserCard = memo(function UserCard({ userId }) {
  const user = useResolve(
    userExecutor,
    (users) => users.find(u => u.id === userId)
  );

  return (
    <div>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
});
```

### Lazy Loading

Use lazy executors for performance:

```typescript
function LazyComponent() {
  const [data] = useResolves(
    expensiveDataExecutor.lazy  // Only loads when needed
  );

  return <ExpensiveView data={data} />;
}
```

## Testing with React Testing Library

```typescript
import { render, screen } from '@testing-library/react';
import { ScopeProvider } from '@pumped-fn/react';
import { exec } from '@pumped-fn/core-next';

// Mock executors for testing
const mockUser = exec(() => ({ name: 'Test User', email: 'test@example.com' }));

test('renders user information', () => {
  render(
    <ScopeProvider>
      <UserProfile />
    </ScopeProvider>
  );

  expect(screen.getByText('Test User')).toBeInTheDocument();
  expect(screen.getByText('test@example.com')).toBeInTheDocument();
});
```

## Server-Side Rendering

Pumped Functions works with SSR:

```typescript
import { ScopeProvider, createScope } from '@pumped-fn/react';

// Server-side
export async function getServerSideProps() {
  const scope = createScope();
  
  // Pre-resolve data on server
  const userData = await scope.resolve(userDataExecutor);
  
  return {
    props: {
      initialData: userData,
    },
  };
}

// Client-side
function App({ initialData }) {
  const scope = createScope();
  
  // Hydrate with server data
  scope.update(userDataExecutor, initialData);

  return (
    <ScopeProvider scope={scope}>
      <Dashboard />
    </ScopeProvider>
  );
}
```

## Best Practices

### 1. Keep Components Simple

Let executors handle the logic:

```typescript
// Good - logic in executor
const userStats = exec(
  (user) => ({
    totalPosts: user.posts.length,
    totalLikes: user.posts.reduce((sum, p) => sum + p.likes, 0),
  }),
  userExecutor.reactive
);

function UserStats() {
  const [stats] = useResolves(userStats);
  return <div>Posts: {stats.totalPosts}, Likes: {stats.totalLikes}</div>;
}
```

### 2. Use Appropriate Hooks

Choose the right hook for your use case:

```typescript
// For multiple values
const [user, settings] = useResolves(userExecutor, settingsExecutor);

// For single value with selector
const userName = useResolve(userExecutor, (user) => user.name);

// For updates
const updateUser = useUpdate(userExecutor);
```

### 3. Handle Loading States

```typescript
function UserProfile() {
  const [user] = useResolves(userExecutor);
  
  if (!user) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

## Common Pitfalls

### 1. Don't Create Executors in Render

```typescript
// Don't do this
function BadComponent() {
  const badExecutor = exec(() => Math.random()); // New executor every render!
  const [value] = useResolves(badExecutor);
  return <div>{value}</div>;
}

// Do this instead
const goodExecutor = exec(() => Math.random());

function GoodComponent() {
  const [value] = useResolves(goodExecutor);
  return <div>{value}</div>;
}
```

### 2. Avoid Unnecessary Reactive Dependencies

```typescript
// Less efficient - entire state is reactive
const userDisplayName = exec(
  (appState) => appState.user.name,
  appStateExecutor.reactive
);

// More efficient - specific reactive dependency
const userDisplayName = exec(
  (user) => user.name,
  userExecutor.reactive
);
```

## Next Steps

- [Testing](/testing/overview) - Learn how to test React components with executors
- [Examples](/examples/counter) - See complete React examples
- [Core Concepts](/core-concepts/executors) - Deep dive into executor patterns

The React integration makes it easy to build reactive, performant applications with Pumped Functions. The hooks and components provide a natural way to connect your executor-based logic to React's component model.