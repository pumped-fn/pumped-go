# Executors

Executors are the fundamental building blocks of Pumped Functions. They are containers that hold values and define how dependencies are resolved, providing a powerful abstraction for dependency injection and reactive programming.

## What Are Executors?

An executor is a container that:
- Holds a **factory function** that creates a value
- Declares **dependencies** on other executors
- Manages the **lifecycle** of the value it creates
- Provides different **resolution strategies** (static, lazy, reactive)

```typescript
import { exec } from '@pumped-fn/core-next';

// Simple executor with no dependencies
const greeting = exec(() => 'Hello, World!');

// Executor with dependencies
const message = exec(
  (greeting: string, name: string) => `${greeting} ${name}!`,
  [greeting, nameExecutor]
);
```

## Creating Executors

### Basic Executor

The simplest executor takes a factory function:

```typescript
import { exec } from '@pumped-fn/core-next';

const config = exec(() => ({
  apiUrl: 'https://api.example.com',
  timeout: 5000,
}));
```

### Executor with Dependencies

Pass dependencies as the second parameter:

```typescript
const apiClient = exec(
  (config: Config) => new ApiClient(config),
  config // Single dependency
);

const userService = exec(
  (client: ApiClient, logger: Logger) => new UserService(client, logger),
  [apiClient, logger] // Multiple dependencies as array
);
```

### Object Dependencies

Use objects to name your dependencies:

```typescript
const combinedService = exec(
  ({ api, cache, logger }) => new CombinedService(api, cache, logger),
  {
    api: apiClient,
    cache: cacheService,
    logger: loggerService,
  }
);
```

## Resolution Strategies

Executors support different resolution strategies that control when and how values are created:

### Static Resolution (Default)

Static executors resolve once and cache the result:

```typescript
const database = exec(() => new Database());
// Or explicitly: database.static
```

### Lazy Resolution

Lazy executors only resolve when their value is actually needed:

```typescript
const expensiveService = exec(() => {
  console.log('Creating expensive service...');
  return new ExpensiveService();
});

// Use lazy resolution
const maybeUseService = exec(
  (service: ExpensiveService) => Math.random() > 0.5 ? service : null,
  expensiveService.lazy // Only creates service if needed
);
```

### Reactive Resolution

Reactive executors automatically re-resolve when their dependencies change:

```typescript
const counter = exec(() => ({ count: 0 }));

const doubled = exec(
  (state) => state.count * 2,
  counter.reactive // Re-resolves when counter changes
);
```

## Dependency Patterns

### Array Dependencies

When you need multiple dependencies in order:

```typescript
const fullName = exec(
  (firstName: string, lastName: string) => `${firstName} ${lastName}`,
  [firstNameExecutor, lastNameExecutor]
);
```

### Object Dependencies

When you want to name your dependencies:

```typescript
const userProfile = exec(
  ({ name, email, preferences }) => ({
    displayName: name,
    contactEmail: email,
    theme: preferences.theme,
  }),
  {
    name: userName,
    email: userEmail,
    preferences: userPreferences,
  }
);
```

### Mixed Dependencies

You can mix static and reactive dependencies:

```typescript
const dynamicComponent = exec(
  (staticConfig: Config, liveData: LiveData) => 
    new Component(staticConfig, liveData),
  {
    staticConfig: configExecutor,         // Static
    liveData: dataExecutor.reactive,      // Reactive
  }
);
```

## Scopes and Resolution

Executors don't resolve themselves - they need a **scope** to manage their lifecycle:

```typescript
import { createScope } from '@pumped-fn/core-next';

const scope = createScope();
const result = scope.resolve(myExecutor);
```

### Scope Management

Scopes provide several methods for managing executors:

```typescript
const scope = createScope();

// Resolve an executor
const value = scope.resolve(myExecutor);

// Update an executor's value
scope.update(myExecutor, newValue);
scope.update(myExecutor, (current) => ({ ...current, updated: true }));

// Release an executor (cleanup)
scope.release(myExecutor);

// Check if an executor is resolved
const isResolved = scope.has(myExecutor);
```

## Async Executors

Executors can handle asynchronous operations:

```typescript
const userData = exec(async () => {
  const response = await fetch('/api/user');
  return response.json();
});

const userProfile = exec(
  async (userData: UserData, preferences: Preferences) => {
    return {
      ...userData,
      theme: preferences.theme,
    };
  },
  [userData, userPreferences]
);

// Resolving async executors
const scope = createScope();
const profile = await scope.resolve(userProfile);
```

## Error Handling

Executors can throw errors, which are propagated through the dependency chain:

```typescript
const riskyService = exec(() => {
  if (Math.random() > 0.5) {
    throw new Error('Service unavailable');
  }
  return new Service();
});

const safeService = exec(
  (service: Service) => service,
  riskyService
);

// Handle errors during resolution
const scope = createScope();
try {
  const service = scope.resolve(safeService);
} catch (error) {
  console.error('Service failed to initialize:', error);
}
```

## Advanced Patterns

### Conditional Dependencies

Use lazy resolution for conditional dependencies:

```typescript
const isDevelopment = exec(() => process.env.NODE_ENV === 'development');

const logger = exec(
  (isDev: boolean) => isDev ? new ConsoleLogger() : new NoOpLogger(),
  isDevelopment
);

const debugService = exec(
  (logger: Logger) => new DebugService(logger),
  logger.lazy // Only creates if logger is actually used
);
```

### Factory Pattern

Create executors that return factory functions:

```typescript
const apiClientFactory = exec(
  (config: Config) => (baseUrl: string) => new ApiClient(config, baseUrl),
  config
);

const userApiClient = exec(
  (factory: ApiClientFactory) => factory('/api/users'),
  apiClientFactory
);
```

### Parameterized Executors

Create executors that accept parameters:

```typescript
const createUserService = (userId: string) => exec(
  (api: ApiClient) => new UserService(api, userId),
  apiClient
);

const currentUserService = exec(
  (currentUserId: string) => createUserService(currentUserId),
  currentUserIdExecutor
);
```

## Testing Executors

Executors are easy to test in isolation:

```typescript
import { describe, it, expect } from 'vitest';
import { createScope } from '@pumped-fn/core-next';

describe('Calculator', () => {
  it('should add two numbers', () => {
    const a = exec(() => 5);
    const b = exec(() => 3);
    const sum = exec((a: number, b: number) => a + b, [a, b]);

    const scope = createScope();
    const result = scope.resolve(sum);

    expect(result).toBe(8);
  });

  it('should handle async operations', async () => {
    const asyncValue = exec(async () => {
      await new Promise(resolve => setTimeout(resolve, 10));
      return 'async result';
    });

    const scope = createScope();
    const result = await scope.resolve(asyncValue);

    expect(result).toBe('async result');
  });
});
```

## Best Practices

### 1. Keep Executors Pure

Executors should be pure functions when possible:

```typescript
// Good - pure function
const calculateTotal = exec(
  (items: Item[]) => items.reduce((sum, item) => sum + item.price, 0),
  itemsExecutor
);

// Avoid - side effects in executor
const updateDatabase = exec(
  (data: Data) => {
    database.save(data); // Side effect
    return data;
  },
  dataExecutor
);
```

### 2. Use Descriptive Names

Make your executors self-documenting:

```typescript
// Good
const currentUserProfile = exec(/* ... */);
const authenticatedApiClient = exec(/* ... */);

// Less clear
const user = exec(/* ... */);
const client = exec(/* ... */);
```

### 3. Organize Dependencies

Group related executors together:

```typescript
// auth.ts
export const authToken = exec(/* ... */);
export const currentUser = exec(/* ... */);

// api.ts
export const apiClient = exec(/* ... */, [authToken]);
export const userService = exec(/* ... */, [apiClient]);
```

### 4. Use Type Annotations

Help TypeScript infer types correctly:

```typescript
interface Config {
  apiUrl: string;
  timeout: number;
}

const config = exec((): Config => ({
  apiUrl: process.env.API_URL || 'http://localhost:3000',
  timeout: 5000,
}));
```

## Performance Considerations

### Lazy Loading

Use lazy resolution for expensive operations:

```typescript
const expensiveComputation = exec(() => {
  // Expensive operation
  return computeComplexValue();
});

const conditionalResult = exec(
  (condition: boolean, value: ComplexValue) => 
    condition ? value : null,
  [conditionExecutor, expensiveComputation.lazy]
);
```

### Reactive Optimization

Be mindful of reactive dependencies to avoid unnecessary re-computations:

```typescript
// Good - specific reactive dependency
const userDisplayName = exec(
  (user) => user.name,
  userExecutor.reactive
);

// Less efficient - entire state is reactive
const userDisplayName = exec(
  (appState) => appState.user.name,
  appStateExecutor.reactive
);
```

## Common Pitfalls

### 1. Circular Dependencies

Avoid circular dependencies between executors:

```typescript
// Don't do this
const a = exec((b: any) => b + 1, b);
const b = exec((a: any) => a + 1, a); // Circular!
```

### 2. Mutating Dependencies

Don't mutate values from dependencies:

```typescript
// Don't do this
const mutateConfig = exec(
  (config: Config) => {
    config.apiUrl = 'modified'; // Don't mutate!
    return config;
  },
  configExecutor
);

// Do this instead
const modifiedConfig = exec(
  (config: Config) => ({
    ...config,
    apiUrl: 'modified',
  }),
  configExecutor
);
```

### 3. Side Effects in Executors

Avoid side effects in executor factories:

```typescript
// Don't do this
const sideEffectExecutor = exec(() => {
  console.log('Creating value'); // Side effect
  localStorage.setItem('key', 'value'); // Side effect
  return 'value';
});

// Do this instead - separate concerns
const value = exec(() => 'value');
const logValue = exec((val: string) => {
  console.log('Value created:', val);
  return val;
}, value);
```

## Next Steps

Now that you understand executors, explore:

- [React Integration](/react/overview) - Using executors with React
- [Testing](/testing/overview) - Testing strategies for executors
- [Examples](/examples/counter) - Real-world examples

Executors are the foundation of Pumped Functions. Master them, and you'll be able to build maintainable, testable, and reactive applications with ease.