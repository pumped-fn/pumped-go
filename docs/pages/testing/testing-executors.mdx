# Testing Executors

Testing executors is straightforward because they are pure functions with explicit dependencies. This guide covers comprehensive testing strategies for all types of executors.

## Basic Executor Testing

### Simple Executors

Test executors with no dependencies:

```typescript
import { describe, it, expect } from 'vitest';
import { exec, createScope } from '@pumped-fn/core-next';

describe('Simple Executors', () => {
  it('should return constant value', () => {
    const greeting = exec(() => 'Hello, World!');
    
    const scope = createScope();
    const result = scope.resolve(greeting);
    
    expect(result).toBe('Hello, World!');
  });

  it('should compute value', () => {
    const currentTime = exec(() => new Date('2023-01-01'));
    
    const scope = createScope();
    const result = scope.resolve(currentTime);
    
    expect(result).toEqual(new Date('2023-01-01'));
  });
});
```

### Executors with Dependencies

Test executors that depend on other executors:

```typescript
describe('Dependent Executors', () => {
  it('should combine values from dependencies', () => {
    const firstName = exec(() => 'John');
    const lastName = exec(() => 'Doe');
    
    const fullName = exec(
      (first: string, last: string) => `${first} ${last}`,
      [firstName, lastName]
    );

    const scope = createScope();
    const result = scope.resolve(fullName);
    
    expect(result).toBe('John Doe');
  });

  it('should handle object dependencies', () => {
    const user = exec(() => ({ name: 'John', age: 30 }));
    const preferences = exec(() => ({ theme: 'dark', lang: 'en' }));
    
    const profile = exec(
      ({ user, prefs }) => ({ ...user, preferences: prefs }),
      { user, prefs: preferences }
    );

    const scope = createScope();
    const result = scope.resolve(profile);
    
    expect(result).toEqual({
      name: 'John',
      age: 30,
      preferences: { theme: 'dark', lang: 'en' }
    });
  });
});
```

## Testing Async Executors

### Basic Async Testing

```typescript
describe('Async Executors', () => {
  it('should resolve async values', async () => {
    const asyncData = exec(async () => {
      await new Promise(resolve => setTimeout(resolve, 10));
      return { data: 'async result' };
    });

    const scope = createScope();
    const result = await scope.resolve(asyncData);

    expect(result.data).toBe('async result');
  });

  it('should handle async dependencies', async () => {
    const asyncUser = exec(async () => {
      await new Promise(resolve => setTimeout(resolve, 5));
      return { id: 1, name: 'John' };
    });

    const userProfile = exec(
      async (user) => ({
        ...user,
        displayName: `User: ${user.name}`,
      }),
      asyncUser
    );

    const scope = createScope();
    const result = await scope.resolve(userProfile);

    expect(result).toEqual({
      id: 1,
      name: 'John',
      displayName: 'User: John'
    });
  });
});
```

### Error Handling

```typescript
describe('Error Handling', () => {
  it('should propagate errors from executors', async () => {
    const failingExecutor = exec(async () => {
      throw new Error('Network error');
    });

    const scope = createScope();
    
    await expect(scope.resolve(failingExecutor))
      .rejects
      .toThrow('Network error');
  });

  it('should handle errors in dependency chain', async () => {
    const failingDep = exec(() => {
      throw new Error('Dependency failed');
    });

    const dependentExecutor = exec(
      (value: any) => `Processed: ${value}`,
      failingDep
    );

    const scope = createScope();
    
    expect(() => scope.resolve(dependentExecutor))
      .toThrow('Dependency failed');
  });
});
```

## Testing Reactive Executors

### Reactive Updates

Test how reactive executors respond to changes:

```typescript
describe('Reactive Executors', () => {
  it('should update when dependency changes', () => {
    const counter = exec(() => ({ count: 0 }));
    const doubled = exec(
      (state) => state.count * 2,
      counter.reactive
    );

    const scope = createScope();
    
    // Initial state
    expect(scope.resolve(doubled)).toBe(0);
    
    // Update dependency
    scope.update(counter, { count: 5 });
    
    // Reactive executor should update
    expect(scope.resolve(doubled)).toBe(10);
  });

  it('should handle multiple reactive dependencies', () => {
    const a = exec(() => 10);
    const b = exec(() => 20);
    
    const sum = exec(
      (a: number, b: number) => a + b,
      [a.reactive, b.reactive]
    );

    const scope = createScope();
    
    // Initial sum
    expect(scope.resolve(sum)).toBe(30);
    
    // Update first dependency
    scope.update(a, 15);
    expect(scope.resolve(sum)).toBe(35);
    
    // Update second dependency
    scope.update(b, 25);
    expect(scope.resolve(sum)).toBe(40);
  });
});
```

### Reactive Chains

Test complex reactive dependency chains:

```typescript
describe('Reactive Chains', () => {
  it('should propagate changes through chain', () => {
    const base = exec(() => 10);
    const doubled = exec((n: number) => n * 2, base.reactive);
    const squared = exec((n: number) => n * n, doubled.reactive);

    const scope = createScope();
    
    // Initial: 10 -> 20 -> 400
    expect(scope.resolve(squared)).toBe(400);
    
    // Update base: 5 -> 10 -> 100
    scope.update(base, 5);
    expect(scope.resolve(squared)).toBe(100);
  });
});
```

## Testing Lazy Executors

### Lazy Resolution

Test that lazy executors only resolve when needed:

```typescript
describe('Lazy Executors', () => {
  it('should only resolve when accessed', () => {
    let resolveCount = 0;
    
    const expensiveExecutor = exec(() => {
      resolveCount++;
      return 'expensive result';
    });

    const conditionalExecutor = exec(
      (condition: boolean, value: string) => condition ? value : null,
      [exec(() => false), expensiveExecutor.lazy]
    );

    const scope = createScope();
    const result = scope.resolve(conditionalExecutor);

    expect(result).toBe(null);
    expect(resolveCount).toBe(0); // Should not have resolved
  });

  it('should resolve when actually needed', () => {
    let resolveCount = 0;
    
    const expensiveExecutor = exec(() => {
      resolveCount++;
      return 'expensive result';
    });

    const conditionalExecutor = exec(
      (condition: boolean, value: string) => condition ? value : null,
      [exec(() => true), expensiveExecutor.lazy]
    );

    const scope = createScope();
    const result = scope.resolve(conditionalExecutor);

    expect(result).toBe('expensive result');
    expect(resolveCount).toBe(1); // Should have resolved once
  });
});
```

## Testing Static Executors

### Caching Behavior

Test that static executors cache their results:

```typescript
describe('Static Executors', () => {
  it('should cache results', () => {
    let callCount = 0;
    
    const cachedExecutor = exec(() => {
      callCount++;
      return Math.random();
    });

    const scope = createScope();
    
    const result1 = scope.resolve(cachedExecutor);
    const result2 = scope.resolve(cachedExecutor);
    
    expect(result1).toBe(result2);
    expect(callCount).toBe(1);
  });

  it('should cache across different scopes', () => {
    let callCount = 0;
    
    const globalExecutor = exec(() => {
      callCount++;
      return 'global value';
    });

    const scope1 = createScope();
    const scope2 = createScope();
    
    const result1 = scope1.resolve(globalExecutor);
    const result2 = scope2.resolve(globalExecutor);
    
    expect(result1).toBe('global value');
    expect(result2).toBe('global value');
    expect(callCount).toBe(1);
  });
});
```

## Mocking Dependencies

### Simple Mocking

Replace dependencies with mock values:

```typescript
describe('Mocking Dependencies', () => {
  it('should work with mock dependencies', () => {
    // Mock dependency
    const mockApiClient = exec(() => ({
      get: (url: string) => Promise.resolve({ data: 'mocked' })
    }));

    const dataService = exec(
      (api) => ({
        fetchData: (url: string) => api.get(url)
      }),
      mockApiClient
    );

    const scope = createScope();
    const service = scope.resolve(dataService);

    expect(service.fetchData).toBeDefined();
  });
});
```

### Using Vitest Mocks

Integrate with Vitest's mocking capabilities:

```typescript
import { vi } from 'vitest';

describe('Service with Mocks', () => {
  it('should use mocked methods', async () => {
    const mockApi = {
      getUser: vi.fn().mockResolvedValue({ id: 1, name: 'John' }),
      updateUser: vi.fn().mockResolvedValue({ success: true })
    };

    const apiExecutor = exec(() => mockApi);
    
    const userService = exec(
      (api) => ({
        getUser: (id: number) => api.getUser(id),
        updateUser: (id: number, data: any) => api.updateUser(id, data)
      }),
      apiExecutor
    );

    const scope = createScope();
    const service = scope.resolve(userService);

    const user = await service.getUser(1);
    expect(user).toEqual({ id: 1, name: 'John' });
    expect(mockApi.getUser).toHaveBeenCalledWith(1);
  });
});
```

## Testing Complex Scenarios

### State Management

Test state management patterns:

```typescript
describe('State Management', () => {
  it('should handle complex state updates', () => {
    const initialState = exec(() => ({
      users: [],
      currentUser: null,
      loading: false
    }));

    const addUser = exec(
      (user: User) => (state: AppState) => ({
        ...state,
        users: [...state.users, user]
      }),
      []
    );

    const setCurrentUser = exec(
      (userId: string) => (state: AppState) => ({
        ...state,
        currentUser: state.users.find(u => u.id === userId) || null
      }),
      []
    );

    const scope = createScope();
    
    // Initial state
    expect(scope.resolve(initialState)).toEqual({
      users: [],
      currentUser: null,
      loading: false
    });

    // Add user
    const newUser = { id: '1', name: 'John' };
    scope.update(initialState, addUser(newUser));
    
    const stateAfterAdd = scope.resolve(initialState);
    expect(stateAfterAdd.users).toHaveLength(1);
    expect(stateAfterAdd.users[0]).toEqual(newUser);

    // Set current user
    scope.update(initialState, setCurrentUser('1'));
    
    const finalState = scope.resolve(initialState);
    expect(finalState.currentUser).toEqual(newUser);
  });
});
```

### Data Transformation

Test data transformation pipelines:

```typescript
describe('Data Transformation', () => {
  it('should transform data through pipeline', () => {
    const rawData = exec(() => [
      { name: 'john doe', age: 25, active: true },
      { name: 'jane smith', age: 30, active: false },
      { name: 'bob johnson', age: 35, active: true }
    ]);

    const normalizedData = exec(
      (data) => data.map(user => ({
        ...user,
        name: user.name.split(' ').map(n => 
          n.charAt(0).toUpperCase() + n.slice(1)
        ).join(' ')
      })),
      rawData
    );

    const activeUsers = exec(
      (data) => data.filter(user => user.active),
      normalizedData
    );

    const userStats = exec(
      (users) => ({
        total: users.length,
        averageAge: users.reduce((sum, u) => sum + u.age, 0) / users.length
      }),
      activeUsers
    );

    const scope = createScope();
    const stats = scope.resolve(userStats);

    expect(stats.total).toBe(2);
    expect(stats.averageAge).toBe(30);
  });
});
```

## Testing Best Practices

### 1. Test One Thing at a Time

Focus each test on a single aspect:

```typescript
describe('UserValidator', () => {
  it('should validate email format', () => {
    const validator = exec(() => ({
      isValidEmail: (email: string) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)
    }));

    const scope = createScope();
    const { isValidEmail } = scope.resolve(validator);

    expect(isValidEmail('test@example.com')).toBe(true);
    expect(isValidEmail('invalid-email')).toBe(false);
  });

  it('should validate password strength', () => {
    const validator = exec(() => ({
      isStrongPassword: (password: string) => password.length >= 8
    }));

    const scope = createScope();
    const { isStrongPassword } = scope.resolve(validator);

    expect(isStrongPassword('strongpassword')).toBe(true);
    expect(isStrongPassword('weak')).toBe(false);
  });
});
```

### 2. Use Descriptive Test Names

Make tests self-documenting:

```typescript
describe('Calculator', () => {
  it('should return 0 when given empty array', () => {
    // Test implementation
  });

  it('should sum positive numbers correctly', () => {
    // Test implementation
  });

  it('should handle negative numbers', () => {
    // Test implementation
  });

  it('should throw error for non-numeric values', () => {
    // Test implementation
  });
});
```

### 3. Use Test Utilities

Create reusable test utilities:

```typescript
// test/executors.ts
export function createMockUser(overrides = {}) {
  return exec(() => ({
    id: '1',
    name: 'Test User',
    email: 'test@example.com',
    ...overrides
  }));
}

export function resolveInScope<T>(executor: Executor<T>) {
  const scope = createScope();
  return scope.resolve(executor);
}

// Usage
it('should format user name', () => {
  const user = createMockUser({ name: 'John Doe' });
  const result = resolveInScope(user);
  expect(result.name).toBe('John Doe');
});
```

### 4. Test Edge Cases

Don't forget edge cases:

```typescript
describe('ArrayUtils', () => {
  it('should handle empty arrays', () => {
    const empty = exec(() => []);
    const sum = exec((arr: number[]) => arr.reduce((a, b) => a + b, 0), empty);
    
    expect(resolveInScope(sum)).toBe(0);
  });

  it('should handle single element arrays', () => {
    const single = exec(() => [42]);
    const sum = exec((arr: number[]) => arr.reduce((a, b) => a + b, 0), single);
    
    expect(resolveInScope(sum)).toBe(42);
  });

  it('should handle null/undefined values', () => {
    const nullValue = exec(() => null);
    const defaulted = exec((val: any) => val || 'default', nullValue);
    
    expect(resolveInScope(defaulted)).toBe('default');
  });
});
```

## Performance Testing

### Measuring Performance

Test performance characteristics:

```typescript
describe('Performance', () => {
  it('should resolve large dependency graphs efficiently', () => {
    const start = performance.now();
    
    // Create large dependency graph
    const executors = Array.from({ length: 1000 }, (_, i) => 
      exec(() => i)
    );
    
    const combined = exec(
      (...values: number[]) => values.reduce((sum, val) => sum + val, 0),
      executors
    );

    const scope = createScope();
    const result = scope.resolve(combined);
    
    const duration = performance.now() - start;
    
    expect(result).toBe(499500); // Sum of 0 to 999
    expect(duration).toBeLessThan(100); // Should be reasonably fast
  });
});
```

## Next Steps

- [Testing React Components](/testing/testing-react) - Test React components that use executors
- [Testing Utilities](/testing/testing-utilities) - Advanced testing utilities and helpers
- [Interactive Testing](/testing/interactive-testing) - Testing user interactions

Testing executors is fundamental to building reliable applications with Pumped Functions. The patterns shown here will help you create comprehensive test suites that catch bugs early and document your application's behavior.