# Testing Overview

Pumped Functions is designed with testing in mind. The functional, dependency-injected architecture makes it easy to test your application logic in isolation, mock dependencies, and verify behavior.

## Why Testing is Easy

### 1. Pure Functions

Executors are typically pure functions, making them predictable and easy to test:

```typescript
import { exec } from '@pumped-fn/core-next';

const calculateTotal = exec(
  (items: Item[]) => items.reduce((sum, item) => sum + item.price, 0),
  itemsExecutor
);

// Easy to test - pure function behavior
```

### 2. Dependency Injection

Dependencies are explicitly declared, making mocking straightforward:

```typescript
const userService = exec(
  (api: ApiClient, logger: Logger) => new UserService(api, logger),
  [apiClient, logger]
);

// Easy to test - mock the dependencies
```

### 3. Isolated Scopes

Each test can have its own scope, preventing test interference:

```typescript
import { createScope } from '@pumped-fn/core-next';

test('isolated test', () => {
  const scope = createScope(); // Fresh scope per test
  // Test logic here
});
```

## Testing Setup

### Installation

```bash
# Using Vitest (recommended)
pnpm add -D vitest

# Or using Jest
pnpm add -D jest @types/jest

# For React testing
pnpm add -D @testing-library/react @testing-library/jest-dom
```

### Configuration

Vitest configuration (`vitest.config.ts`):

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom', // For React testing
    setupFiles: ['./src/test/setup.ts'],
  },
});
```

Test setup (`src/test/setup.ts`):

```typescript
import '@testing-library/jest-dom';
```

## Testing Strategies

### 1. Unit Testing

Test individual executors in isolation:

```typescript
import { describe, it, expect } from 'vitest';
import { exec, createScope } from '@pumped-fn/core-next';

describe('Calculator', () => {
  it('should add two numbers', () => {
    const a = exec(() => 5);
    const b = exec(() => 3);
    const sum = exec((a: number, b: number) => a + b, [a, b]);

    const scope = createScope();
    const result = scope.resolve(sum);

    expect(result).toBe(8);
  });
});
```

### 2. Integration Testing

Test how executors work together:

```typescript
describe('User Profile Integration', () => {
  it('should create complete user profile', () => {
    const userData = exec(() => ({ name: 'John', email: 'john@example.com' }));
    const preferences = exec(() => ({ theme: 'dark', lang: 'en' }));
    
    const profile = exec(
      (user, prefs) => ({ ...user, ...prefs }),
      [userData, preferences]
    );

    const scope = createScope();
    const result = scope.resolve(profile);

    expect(result).toEqual({
      name: 'John',
      email: 'john@example.com',
      theme: 'dark',
      lang: 'en',
    });
  });
});
```

### 3. Reactive Testing

Test reactive behavior:

```typescript
describe('Reactive Updates', () => {
  it('should update derived values when source changes', () => {
    const counter = exec(() => ({ count: 0 }));
    const doubled = exec(
      (state) => state.count * 2,
      counter.reactive
    );

    const scope = createScope();
    
    // Initial state
    expect(scope.resolve(doubled)).toBe(0);
    
    // Update source
    scope.update(counter, { count: 5 });
    
    // Derived value should update
    expect(scope.resolve(doubled)).toBe(10);
  });
});
```

## Testing Patterns

### Mock Dependencies

Replace dependencies with mocks:

```typescript
import { vi } from 'vitest';

describe('UserService', () => {
  it('should fetch user data', async () => {
    // Mock API client
    const mockApiClient = exec(() => ({
      getUser: vi.fn().mockResolvedValue({ id: 1, name: 'John' }),
    }));

    const userService = exec(
      (api) => ({
        fetchUser: (id: number) => api.getUser(id),
      }),
      mockApiClient
    );

    const scope = createScope();
    const service = scope.resolve(userService);
    
    const user = await service.fetchUser(1);
    expect(user).toEqual({ id: 1, name: 'John' });
  });
});
```

### Test Factories

Create reusable test data:

```typescript
// test/factories.ts
export const createUser = (overrides = {}) => ({
  id: 1,
  name: 'Test User',
  email: 'test@example.com',
  ...overrides,
});

export const createUserExecutor = (user = {}) => 
  exec(() => createUser(user));

// In tests
describe('User Profile', () => {
  it('should display user name', () => {
    const user = createUserExecutor({ name: 'Custom Name' });
    const scope = createScope();
    
    const result = scope.resolve(user);
    expect(result.name).toBe('Custom Name');
  });
});
```

### Async Testing

Test async executors:

```typescript
describe('Async Operations', () => {
  it('should handle async data fetching', async () => {
    const asyncData = exec(async () => {
      await new Promise(resolve => setTimeout(resolve, 10));
      return { data: 'async result' };
    });

    const scope = createScope();
    const result = await scope.resolve(asyncData);

    expect(result.data).toBe('async result');
  });

  it('should handle errors', async () => {
    const failingExecutor = exec(async () => {
      throw new Error('Network error');
    });

    const scope = createScope();
    
    await expect(scope.resolve(failingExecutor))
      .rejects
      .toThrow('Network error');
  });
});
```

### State Testing

Test state updates:

```typescript
describe('State Management', () => {
  it('should update state correctly', () => {
    const state = exec(() => ({ count: 0, name: 'initial' }));
    const scope = createScope();

    // Initial state
    expect(scope.resolve(state)).toEqual({ count: 0, name: 'initial' });

    // Update with function
    scope.update(state, (current) => ({ ...current, count: current.count + 1 }));
    expect(scope.resolve(state).count).toBe(1);

    // Update with value
    scope.update(state, { count: 5, name: 'updated' });
    expect(scope.resolve(state)).toEqual({ count: 5, name: 'updated' });
  });
});
```

## Testing Best Practices

### 1. Arrange-Act-Assert Pattern

Structure your tests clearly:

```typescript
describe('Calculator', () => {
  it('should calculate percentage', () => {
    // Arrange
    const value = exec(() => 200);
    const percentage = exec(() => 15);
    const result = exec(
      (val: number, pct: number) => (val * pct) / 100,
      [value, percentage]
    );
    const scope = createScope();

    // Act
    const calculation = scope.resolve(result);

    // Assert
    expect(calculation).toBe(30);
  });
});
```

### 2. Test Behavior, Not Implementation

Focus on what the executor does, not how:

```typescript
// Good - tests behavior
it('should format user display name', () => {
  const user = exec(() => ({ firstName: 'John', lastName: 'Doe' }));
  const displayName = exec(
    (user) => `${user.firstName} ${user.lastName}`,
    user
  );

  const scope = createScope();
  const result = scope.resolve(displayName);

  expect(result).toBe('John Doe');
});
```

### 3. Use Descriptive Test Names

Make your tests self-documenting:

```typescript
describe('User Authentication', () => {
  it('should return true when user has valid token', () => {
    // Test implementation
  });

  it('should return false when token is expired', () => {
    // Test implementation
  });

  it('should throw error when token is malformed', () => {
    // Test implementation
  });
});
```

### 4. Group Related Tests

Organize tests with `describe` blocks:

```typescript
describe('ShoppingCart', () => {
  describe('adding items', () => {
    it('should add item to empty cart', () => {
      // Test implementation
    });

    it('should increment quantity for existing item', () => {
      // Test implementation
    });
  });

  describe('removing items', () => {
    it('should remove item completely', () => {
      // Test implementation
    });

    it('should decrement quantity', () => {
      // Test implementation
    });
  });
});
```

## Advanced Testing Techniques

### Property-Based Testing

Use libraries like `fast-check` for property-based testing:

```typescript
import fc from 'fast-check';

describe('Math Operations', () => {
  it('should be commutative for addition', () => {
    fc.assert(
      fc.property(fc.integer(), fc.integer(), (a, b) => {
        const sum1 = exec((a: number, b: number) => a + b, [exec(() => a), exec(() => b)]);
        const sum2 = exec((a: number, b: number) => a + b, [exec(() => b), exec(() => a)]);
        
        const scope = createScope();
        return scope.resolve(sum1) === scope.resolve(sum2);
      })
    );
  });
});
```

### Snapshot Testing

Test complex output structures:

```typescript
describe('Configuration', () => {
  it('should generate correct config structure', () => {
    const config = exec(() => ({
      api: { url: 'https://api.example.com', timeout: 5000 },
      features: { newUI: true, analytics: false },
      theme: { mode: 'dark', colors: ['#000', '#fff'] },
    }));

    const scope = createScope();
    const result = scope.resolve(config);

    expect(result).toMatchSnapshot();
  });
});
```

### Performance Testing

Test performance characteristics:

```typescript
describe('Performance', () => {
  it('should resolve large dependency tree efficiently', () => {
    const executors = Array.from({ length: 1000 }, (_, i) => 
      exec(() => i)
    );
    
    const combined = exec(
      (...values: number[]) => values.reduce((sum, val) => sum + val, 0),
      executors
    );

    const scope = createScope();
    const start = performance.now();
    
    const result = scope.resolve(combined);
    
    const end = performance.now();
    const duration = end - start;

    expect(result).toBe(499500); // Sum of 0 to 999
    expect(duration).toBeLessThan(100); // Should be fast
  });
});
```

## Common Testing Patterns

### Test Data Builders

Create flexible test data:

```typescript
class UserBuilder {
  private user = {
    id: 1,
    name: 'Test User',
    email: 'test@example.com',
    active: true,
  };

  withName(name: string) {
    this.user.name = name;
    return this;
  }

  withEmail(email: string) {
    this.user.email = email;
    return this;
  }

  inactive() {
    this.user.active = false;
    return this;
  }

  build() {
    return this.user;
  }

  buildExecutor() {
    return exec(() => this.build());
  }
}

// Usage
const user = new UserBuilder()
  .withName('John Doe')
  .withEmail('john@example.com')
  .buildExecutor();
```

### Test Utilities

Create reusable test utilities:

```typescript
// test/utils.ts
export function createTestScope() {
  return createScope();
}

export function resolveExecutor<T>(executor: Executor<T>, scope = createTestScope()) {
  return scope.resolve(executor);
}

export function expectToResolve<T>(executor: Executor<T>, expectedValue: T) {
  const scope = createTestScope();
  const result = scope.resolve(executor);
  expect(result).toEqual(expectedValue);
}

// Usage
it('should calculate correctly', () => {
  expectToResolve(calculatorExecutor, 42);
});
```

## Next Steps

- [Testing Executors](/testing/testing-executors) - Deep dive into executor testing
- [Testing React Components](/testing/testing-react) - React-specific testing patterns
- [Testing Utilities](/testing/testing-utilities) - Advanced testing utilities
- [Interactive Testing](/testing/interactive-testing) - Testing with user interactions

Testing is a first-class citizen in Pumped Functions. The architecture naturally supports testing, making it easy to write comprehensive, maintainable tests for your applications.