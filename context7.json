{
  "$schema": "https://context7.com/schema/context7.json",
  "projectTitle": "Pumped Functions",
  "description": "Graph-based dependency injection for TypeScript with type-safe reactive executors, preset-based testing, and lifecycle management for production applications",
  "folders": ["docs"],
  "excludeFolders": [
    "docs/node_modules",
    "docs/.vitepress/cache",
    "docs/.vitepress/dist"
  ],
  "excludeFiles": ["**/*.test.ts", "tsconfig.json"],
  "rules": [
    "CODING STYLE AND CONVENTIONS:",
    "Prefer type inference over explicit types. Let TypeScript infer return types from factory functions",
    "Light naming without suffixes. Use 'config' not 'configMeta', 'logger' not 'loggerExecutor', 'database' not 'databaseService'",
    "TypeScript types convey nature of values. Avoid redundant suffixes that duplicate type information",
    "Use Promised<T> for method chaining. Instead of 'await scope.resolve(executor)', use 'scope.resolve(executor).map(...)' to avoid extra variable naming",
    "Promised extends Promise with map/flatMap/tap methods for fluent chains without intermediate awaits",
    "Name executors and meta functions concisely. Closure context makes their nature clear",

    "GRAPH RESOLUTION MECHANICS:",
    "Executors form directed acyclic graphs (DAGs). Circular dependencies throw errors at resolution time, not declaration time",
    "Resolution happens lazily: declare executors anywhere, graph is only traversed when scope.resolve() or scope.exec() is called",
    "Each executor resolves exactly once per scope unless updated. Cache persists for scope lifetime",
    "Dependencies resolve in parallel when possible. Only sequential when dependency chain requires it",
    "Use derive() to declare dependencies. First argument defines upstream nodes in the graph",

    "GRAPH DESIGN IMPLICATIONS:",
    "Design executors as small, focused nodes. Large monolithic executors cannot be partially replaced in tests",
    "Extract configuration into separate executors (config, dbConfig, apiConfig) for independent testing",
    "Shared dependencies create diamond patterns. Library handles deduplication automatically",
    "Deep dependency chains increase resolution time. Consider lazy executors for rarely-used branches",
    "Graph structure is static after declaration. Dynamic dependencies require factory functions that return executors",

    "TESTING STRATEGY (PRESET-BASED, NOT MOCKING):",
    "Use preset(executor, value) to replace graph nodes, not vi.mock() or similar mocking frameworks",
    "preset() accepts static values OR executor replacements. Both are type-safe and verified at compile time",
    "Multiple presets compose naturally. Pass array of presets to createScope() or scope.exec() options",
    "Preset replacement happens before graph resolution. No runtime interception or proxy magic",
    "Test real implementations by presetting only external dependencies (database, API clients, file system)",
    "Each test creates isolated scope with different preset combinations to verify behavior under various conditions",

    "PRODUCTION LIFECYCLE MANAGEMENT:",
    "createScope() for application lifetime (server instance, worker process, application context)",
    "scope.exec() creates pod (short-lived context) for request handlers, job processing, isolated operations",
    "Pod inherits resolved values from parent scope but maintains isolated local state",
    "ALWAYS call scope.dispose() on application shutdown. Triggers cleanup callbacks in reverse resolution order",
    "Use controller.cleanup() inside executor factories to register resource cleanup (connections, file handles, timers)",
    "Cleanup executes: pod disposal → scope disposal → extension disposal",

    "EXECUTOR VARIANTS AND WHEN TO USE:",
    "Default executor: cached, resolved once per scope. Use for expensive resources (database pools, config)",
    "executor.reactive: re-executes when upstream changes via scope.update(). Use for derived state that must stay synchronized",
    "executor.lazy: defers resolution until explicitly requested. Use for optional features or heavy initialization",
    "executor.static: returns Accessor for manual control. Use when you need update() capability without automatic reactivity",
    "Reactive executors only re-execute if they depend on .reactive upstream. Normal dependency on reactive executor doesn't trigger updates",

    "SCOPE VS POD USAGE:",
    "Scope holds long-lived resources. Database connections, HTTP servers, message queues belong in scope",
    "Pod represents single operation context. HTTP request, background job, transaction boundary use pod",
    "Pod disposal does NOT dispose scope resources. Multiple pods share scope resources safely",
    "Extensions can hook into pod lifecycle: initPod() before execution, disposePod() after completion",
    "Use scope.createPod() for manual pod management. Use scope.exec(flow, input, options) for automatic pod lifecycle",

    "ERROR HANDLING IN GRAPHS:",
    "Executor factory errors wrap in ExecutorResolutionError with full dependency chain context",
    "Circular dependency errors show complete circular path: A → B → C → A",
    "Errors during resolution stop graph traversal immediately. Scope remains in valid state",
    "Failed executors cache error state. Subsequent resolution attempts return same error without re-executing",
    "Use controller.cleanup() even in executors that might fail. Cleanup runs for all successfully resolved dependencies",

    "FLOW DESIGN:",
    "flow() creates executable units with automatic pod management and lifecycle hooks",
    "flow.define() adds schema validation for inputs/outputs. Validation errors throw before handler execution",
    "Flows can depend on executors via first parameter: flow(database, (deps, ctx, input) => ...)",
    "Flow context (ctx) provides scoped data storage. Nested flows fork context creating parent-child chain",
    "Use flow for: API endpoints, background jobs, business operations, anything with clear input/output",

    "EXTENSION SYSTEM (CRITICAL FOR SYSTEM DESIGN):",
    "Extensions provide cross-cutting concerns without modifying business logic: transactions, logging, metrics, tracing, auth",
    "Extension interface has 7 hooks: init, initPod, wrap, onError, onPodError, dispose, disposePod",
    "Extension lifecycle: init(scope) → initPod(pod) → wrap(operations) → disposePod(pod) → dispose(scope)",

    "EXTENSION HOOKS EXPLAINED:",
    "init(scope): runs once when scope created. Initialize scope-level resources (APM clients, metric collectors)",
    "initPod(pod, context): runs before EACH flow execution. Setup request context, begin transactions, create tracing spans",
    "wrap<T>(context, next, operation): intercepts ALL operations (execute, journal, subflow, parallel). Wrap with timing, tracing, error handling",
    "onError(error, scope): handles executor resolution errors at scope level. Log, report to APM, trigger alerts",
    "onPodError(error, pod, context): handles flow execution errors. Rollback transactions, log with request context",
    "dispose(scope): runs once at scope disposal. Close APM clients, flush metrics, cleanup scope resources",
    "disposePod(pod): runs after EACH flow completes. Commit/rollback transactions, close spans, emit metrics",

    "OPERATION TYPES IN wrap():",
    "operation.kind === 'execute': initial flow entry point. Access operation.definition (flow metadata) and operation.input",
    "operation.kind === 'journal': ctx.run() calls. Access operation.key (string) and operation.params (arguments array)",
    "operation.kind === 'subflow': ctx.exec() nested flow calls. Access operation.definition and operation.input",
    "operation.kind === 'parallel': ctx.parallel() concurrent operations. Access operation.mode ('parallel'|'settled') and operation.promiseCount",

    "EXTENSION CAPABILITIES:",
    "Extensions can resolve executors: const db = await pod.resolve(database)",
    "Extensions can store values in context: context.set(transactionAccessor, tx)",
    "Extensions can read flow metadata: operation.definition.name, operation.definition.version",
    "Extensions can measure timing: wrap() captures start time, calculates duration in then()/catch()",
    "Extensions can modify error handling: catch in wrap(), transform error, rethrow or handle",
    "Extensions compose: multiple extensions run in order, each wrapping the next",

    "EXTENSION DESIGN PATTERNS:",
    "Transaction pattern: initPod begins transaction, disposePod commits/rollbacks based on error",
    "Logging pattern: wrap() logs all operations with timing, parameters, results",
    "Tracing pattern: initPod creates span, wrap() adds operation attributes, disposePod closes span",
    "Circuit breaker pattern: wrap() tracks failures, open circuit on threshold, fail fast",
    "Retry pattern: wrap() catches errors, retry with backoff, eventually throw",
    "Auth pattern: initPod validates credentials, store user in context, check in wrap()",
    "Metrics pattern: wrap() increments counters, measures durations, records histograms",

    "PERFORMANCE CONSIDERATIONS:",
    "Executor resolution cost: single promise creation + dependency resolution + factory execution",
    "Cached executors have near-zero cost on second access (Map lookup)",
    "Reactive chains propagate updates synchronously through graph. Deep reactive chains may cause cascading updates",
    "Lazy executors delay work until needed. Use for optional features or environment-specific resources",
    "Pod creation is lightweight (forked Map). Create pods freely for isolated operations",

    "RESOURCE CLEANUP:",
    "Register cleanup via controller.cleanup(fn) inside executor factory",
    "Cleanup functions execute in REVERSE resolution order (leaves first, roots last)",
    "Failed executors do not register cleanup. Only successfully resolved executors clean up",
    "Cleanup is async-safe. Awaits all cleanup promises before completing disposal",
    "Reactive updates trigger cleanup of previous value before re-execution",

    "TYPE SAFETY PATTERNS:",
    "Executor types infer from factory return type automatically. No manual type annotations needed",
    "derive() dependency types checked against factory parameter types. Mismatches are compile errors",
    "preset() enforces type compatibility. Cannot preset Executor<string> with number value",
    "Flow input/output schemas validated at runtime. Type guards ensure type safety at boundaries",
    "Use custom<T>() schema for TypeScript-only validation. Use zod/valibot/etc for runtime validation",

    "COMMON PRODUCTION PITFALLS:",
    "Forgetting scope.dispose() causes resource leaks (connections, timers, file handles remain open)",
    "Circular dependencies only detected at resolution time. Test all execution paths",
    "Reactive executors without .reactive upstream never update. Explicit .reactive declaration required",
    "Presetting wrong executor in tests causes confusion. Name executors with meta() for debugging",
    "Deep reactive chains can cause performance issues. Limit reactive depth or debounce updates",

    "NAMING AND DEBUGGING:",
    "Use meta() functions to attach metadata: name('database'), version('1.0'), tags(['critical'])",
    "Named executors appear in error messages with dependency chains for debugging",
    "Error context includes: executor name, dependency chain, resolution stage, timestamp",
    "Use scope.accessor(executor).metas to inspect metadata at runtime",

    "MIGRATION AND INTEGRATION:",
    "Incrementally adopt by wrapping existing code in provide() executors",
    "Integrate with existing DI frameworks by presetting their instances into pumped-fn scope",
    "Use flow() to wrap existing business logic without refactoring",
    "Extensions can bridge to external systems (APM, logging frameworks, transaction managers)"
  ]
}
